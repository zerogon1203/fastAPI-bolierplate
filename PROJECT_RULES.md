# FastAPI 보일러플레이트 프로젝트 규칙

## 1. 프로젝트 구조 규칙

### 디렉토리 구조
```
app/
├── api/                  # API 라우터들
│   ├── v1/              # API 버전 관리
│   │   ├── endpoints/   # 엔드포인트 별 라우터
│   │   └── api.py       # API 라우터 통합
│   └── deps.py          # 의존성 주입
├── core/                # 핵심 설정
│   ├── config.py        # 환경 설정
│   ├── security.py      # 보안 관련 설정
│   └── database.py      # 데이터베이스 설정
├── ai/                  # AI/LLM 관련 모듈
│   ├── chains/          # Langchain 체인들
│   ├── agents/          # AI 에이전트들
│   ├── tools/           # AI 도구들
│   ├── prompts/         # 프롬프트 템플릿
│   ├── embeddings/      # 임베딩 관련
│   ├── memory/          # 대화 메모리
│   ├── mcp/             # MCP 서버/클라이언트
│   │   ├── servers/     # MCP 서버 구현
│   │   ├── clients/     # MCP 클라이언트
│   │   └── tools/       # MCP 도구들
│   └── providers/       # LLM 프로바이더 설정
├── models/              # 데이터 모델
├── schemas/             # Pydantic 스키마
├── services/            # 비즈니스 로직
├── utils/               # 유틸리티 함수
├── config/              # 설정 파일들
│   └── mcp_servers.json # MCP 서버 설정
└── main.py              # 애플리케이션 진입점
```

## 2. 코딩 컨벤션

### 네이밍 규칙
- **파일명**: snake_case (예: user_service.py)
- **클래스명**: PascalCase (예: UserService)
- **함수명/변수명**: snake_case (예: get_user_by_id)
- **상수명**: UPPER_SNAKE_CASE (예: DATABASE_URL)

### 라우터 규칙
- 각 라우터는 독립적인 파일로 관리
- 라우터 파일명은 관련 리소스명 사용 (예: users.py, items.py)
- 라우터 태그는 복수형 사용 (예: "users", "items")
- 엔드포인트 경로는 RESTful 규칙 준수

## 3. 환경 관리

### 환경 변수
- `.env` 파일로 환경별 설정 관리
- 민감한 정보는 환경 변수로만 관리
- 개발/스테이징/프로덕션 환경 분리

### 설정 관리
- Pydantic Settings 사용
- 환경별 설정 클래스 분리
- 타입 힌트 적극 활용

## 4. 보안 규칙

### 인증/인가
- JWT 토큰 기반 인증 구현
- OAuth2 with Password Bearer 사용
- 비밀번호 해싱은 bcrypt 사용
- 토큰 만료 시간 설정

### API 보안
- CORS 설정 적용
- 입력 데이터 검증 (Pydantic)
- SQL Injection 방지 (ORM 사용)
- Rate Limiting 적용

## 5. 데이터베이스 규칙

### ORM 사용
- SQLAlchemy ORM 사용
- 마이그레이션은 Alembic 사용
- 모델과 스키마 분리

### 데이터베이스 연결
- 커넥션 풀링 설정
- 트랜잭션 관리
- 데이터베이스 헬스체크 구현

## 6. 테스트 규칙

### 테스트 구조
- pytest 사용
- 단위 테스트와 통합 테스트 분리
- 테스트 데이터베이스 분리

### 테스트 파일명
- `test_` 접두사 사용
- 테스트 대상과 동일한 구조로 배치

## 7. 로깅 및 모니터링

### 로깅
- 구조화된 로깅 (JSON 형태)
- 로그 레벨 설정 (DEBUG, INFO, WARNING, ERROR)
- 요청/응답 로깅

### 모니터링
- 헬스체크 엔드포인트 구현
- 메트릭 수집을 위한 엔드포인트
- 에러 추적 및 알림

## 8. 문서화 규칙

### API 문서
- OpenAPI 자동 생성 활용
- 각 엔드포인트에 설명 추가
- 예제 데이터 포함

### 코드 문서
- 독스트링 작성 (Google 스타일)
- 타입 힌트 적극 활용
- README.md 업데이트

## 9. 배포 규칙

### 컨테이너화
- Docker 이미지 생성
- multi-stage 빌드 사용
- 최소한의 이미지 크기 유지

### 환경 설정
- 환경별 Docker Compose 파일
- 시크릿 관리 (Docker Secrets 또는 K8s Secrets)

## 10. 성능 최적화

### 비동기 처리
- async/await 패턴 사용
- 비동기 데이터베이스 드라이버 사용
- 백그라운드 태스크 활용

### 캐싱
- Redis 캐싱 구현
- 쿼리 결과 캐싱
- API 응답 캐싱

## 11. AI/LLM 통합 규칙

### Langchain 사용 규칙
- **체인 구성**: 간단한 작업부터 복잡한 체인까지 단계적 구성
- **프롬프트 관리**: 체계적인 프롬프트 템플릿 관리
- **메모리 활용**: 대화 컨텍스트 유지를 위한 메모리 사용
- **에이전트 설계**: 목적에 맞는 에이전트 구성
- **도구 통합**: 외부 API와 서비스를 도구로 통합

### LLM 프로바이더 관리
- **다중 프로바이더 지원**: OpenAI, Anthropic, Google 등 지원
- **모델 선택**: 작업에 적합한 모델 자동 선택
- **비용 최적화**: 토큰 사용량 모니터링 및 최적화
- **백업 프로바이더**: 장애 대응을 위한 백업 설정

### MCP (Model Context Protocol) 규칙
- **서버 구현**: 표준 MCP 프로토콜 준수
- **클라이언트 연결**: 안전한 클라이언트-서버 통신
- **도구 노출**: 비즈니스 로직을 MCP 도구로 노출
- **상태 관리**: MCP 세션 상태 적절히 관리
- **에러 처리**: MCP 통신 오류 적절히 처리

### AI 보안 규칙
- **입력 검증**: LLM 입력 데이터 철저한 검증
- **출력 필터링**: LLM 출력 결과 안전성 검사
- **프롬프트 주입 방지**: 악의적 프롬프트 주입 차단
- **API 키 보안**: LLM API 키 안전한 관리
- **사용량 제한**: Rate limiting 및 사용량 제한

### 벡터 데이터베이스 활용
- **임베딩 생성**: 효율적인 텍스트 임베딩 생성
- **유사도 검색**: 의미 기반 검색 구현
- **RAG 패턴**: Retrieval-Augmented Generation 구현
- **벡터 저장**: 임베딩 벡터 효율적 저장 관리
- **업데이트 전략**: 벡터 데이터 업데이트 전략

### 모니터링 및 관찰성
- **LangSmith 통합**: Langchain 실행 추적 및 모니터링
- **토큰 사용량 추적**: LLM API 사용량 모니터링
- **성능 메트릭**: AI 작업 성능 측정
- **에러 추적**: AI 관련 에러 상세 추적
- **사용자 피드백**: AI 응답 품질 피드백 수집 